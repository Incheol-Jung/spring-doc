### **1.2. Container Overview**

The `org.springframework.context.ApplicationContext` interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.

<aside>
💡 `ApplicationContext` 인터페이스는 빈들을 구성, 조립 인스턴스화를 담당하는 Spring IoC 컨테이너를 담당한다. 컨테이너는 구성 메타정보를 읽어서 오브젝트의 구성, 조합 정보를 얻는다. 구성 메타정보들은 XML에 표현되거나 자바 코드 또는 어노테이션들에 있다. 이는 당신이 오브젝트들 간의 풍부한 상호 종속성을 표현할수 있게 해준다.

</aside>

Several implementations of the `ApplicationContext` interface are supplied with Spring. In stand-alone applications, it is common to create an instance of `[ClassPathXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.16/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html)` or `[FileSystemXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.16/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html)`. While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.

<aside>
💡 스프링에는 `ApplicationContext` 인터페이스의 여러 구현체가 제공된다. 독립 실행형 응용 프로그램에서는 ClassPathXmlApplicationContext 또는 FileSystemXmlApplicationContext의 인스턴스를 만드는 것이 일반적이다. XML은 전통적인 메타정보 구성 방식이지만, 당신은 어노테이션이나 코드 사용하여 컨테이너에 제공할 수 있다.

</aside>

In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the `web.xml` file of the application typically suffices (see [Convenient ApplicationContext Instantiation for Web Applications](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-create)). If you use the [Spring Tools for Eclipse](https://spring.io/tools) (an Eclipse-powered development environment), you can easily create this boilerplate configuration with a few mouse clicks or keystrokes.

<aside>
💡 대부분의 애플리케이션 시나리오에서 하나 이상의 Spring IoC 컨테이너 인스턴스를 인스턴스화하는 데 명시적 사용자 코드가 필요하지 않는다. 예를 들어 웹 애플리케이션 시나리오에서 애플리케이션의 web.xml 파일에 있는 보일러 플래이트 8줄이면 충분하다. 만약 이클립스를 사용한다면 클릭 몇번 또는 키 입력만으로도 이 보일러플레이트 코드를 쉽게 생성할 수 있다.

</aside>

The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the `ApplicationContext` is created and initialized, you have a fully configured and executable system or application.

<aside>
💡 다음 다이어그램은 스프링이 어떻게 동작하는지 고수준으로 보여준다. 당신의 애플리케이션 클래스들은 구성 메타정보로 조화되어있고, `ApplicationContext` 가 생성하고 인스턴스화 되어진 이후에, 전체 구성 및 실행 가능한 시스템 또는 애플리케이션을 가질수 있다.

</aside>

![images](../../images/container-magic.png)

### **1.2.1. Configuration Metadata**

As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application.

Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.

<aside>
💡 위의 다이어그램에서 알 수 있듯이 Spring IoC 컨테이너는 구성 메타데이터의 형태를 사용한다. 이 구성 메타데이터는 애플리케이션 개발자가 스프링 컨테이너에 애플리케이션의 개체를 인스턴스화, 구성 및 조립하도록 지시하는 방법을 나타낸다. 
구성 메타데이터는 전통적으로 단순하고 직관적인 XML 형식으로 제공되며, 이 장에서는 대부분 Spring IoC 컨테이너의 주요 개념과 기능을 전달하는 데 사용한다.

</aside>

> XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose [Java-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) for their Spring applications.
>

<aside>
💡 XML 기반 메타데이터만 허용되는 구성 메타데이터 형식이 아니다. Spring IoC 컨테이너는 작성된 메타 정보로 부터 완전히 분리된다. 최근에 많은 개발자들은 자바 코드 기반으로 설정하는것을 택한다.

</aside>

For information about using other forms of metadata with the Spring container, see:

- [Annotation-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config): Spring 2.5 introduced support for annotation-based configuration metadata.
- [Java-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java): Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the `[@Configuration](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)`, `[@Bean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)`, `[@Import](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html)`, and `[@DependsOn](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html)` annotations.

<aside>
💡 스프링 컨테이너에 쓰여진 메타 정보 형식에 대한 정보를 보려면 다음을 살펴보면 된다. 
- 어노테이션 기반 설정 : 스프링 2.5버전부터 제공된다. 
- 자바 코드 기반 설정 : 스프링 3.0에서 많은 기능들이 코어 스프링 프레임워크의 한 부분으로 들어오면서 많은 기능들이 제공되었다. 그래서, 당신은 XML 파일을 작성하기 보다는 자바 코드를 사용하여 클래스 외부에서 bean들을 정의할 수 있다. 새로운 기능들을 사용하기 위해서는 `[@Configuration](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)`, `[@Bean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)`, `[@Import](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html)`, and `[@DependsOn](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html)` 어노테이션 가이드 문서를 확인해라

</aside>

Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as `<bean/>` elements inside a top-level `<beans/>` element. Java configuration typically uses `@Bean`-annotated methods within a `@Configuration` class.

These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts `Action` instances, infrastructure objects such as Hibernate `SessionFactories`, JMS `Queues`, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See [Using AspectJ to dependency-inject domain objects with Spring](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable).

<aside>
💡 스프링 구성은 컨테이너가 관리해야 하는 하나 이상의 빈 정의로 구성된다. XML 기반 구성 메타데이터는 이러한 빈을 최상위 수준의 <bean/> 요소 내에 있는 <bean/> 요소로 구성된다. Java 구성은 일반적으로 @Configuration 클래스 내에서 @Bean 주석 메소드를 사용한다. 

정의된 빈은 애플리케이션을 구성하는 실제 오브젝트에 해당된다. 일반적으로, 서비스레이어 객체, 데이터 접근 객체, 표현 객체, 하이버네이트 SessionFactories와 같은 인프라스터럭쳐 객체등을 정의할 수 있다. 일반적으로 도메인 개체를 만들고 로드하는 것은 DAO와 비즈니스 로직의 책임이기 때문에 컨테이너에서 세분화된 도메인 개체로 구성하지 않는다. 일반적으로 도메인 개체를 만들고 로드하는 것은 DAO와 비즈니스 로직의 책임이기 때문에 컨테이너에서 세분화된 도메인 개체를 구성하지 않는다.

</aside>

> 🙇  1.2.2는 XML을 다루는 부분이라 생략 하였습니다.
>

### **1.2.3. Using the Container**

The `ApplicationContext` is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method `T getBean(String name, Class<T> requiredType)`, you can retrieve instances of your beans.

The `ApplicationContext` lets you read bean definitions and access them, as the following example shows:

**Java**

```sql
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

<aside>
💡 ApplicationContext는 다양한 bean과 의존성의 레지스트리를 관리할 수 있는 고급 팩토리의 인터페이스이다. T getBean(String name, Class<T> requiredType)를 사용하여, 빈들의 인스턴스를 가져올 수 있다.

</aside>

With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration:

**Java**

```sql
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

<aside>
💡 Groovy 설정으로는 부트스트래핑과 매우 유사하다. 이는 그루비를 이해하는 다른 컨텍스트 구현 클래스를 가지고 있다. 다음은 Groovy 설정을 보여주는 예이다.

</aside>

The most flexible variant is `GenericApplicationContext` in combination with reader delegates — for example, with `XmlBeanDefinitionReader` for XML files, as the following example shows:

**Java**

```sql
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

<aside>
💡 위임 리더기를 가진 조합중에서 가장 유연한 타입은 `GenericApplicationContext` 이다. 다음 예제는 XML 파일을 읽는 `XmlBeanDefinitionReader` 를 사용한 사례이다.

</aside>

You can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following example shows:

**Java**

```sql
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

<aside>
💡 다음 사례는 Groovy 파일을 읽는 `GroovyBeanDefinitionReader` 를 사용한 사례이다.

</aside>

You can mix and match such reader delegates on the same `ApplicationContext`, reading bean definitions from diverse configuration sources.

You can then use `getBean` to retrieve instances of your beans. The `ApplicationContext` interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the `getBean()` method at all and thus have no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).

<aside>
💡 다양한 구성 소스에서 빈 정의를 읽어주는 동일한 `ApplicationContext` 을 혼합하여 사용할 수 있다. 

그 다음엔 getBean을 사용해서 빈 인스턴스를 가져올 수 있다. `ApplicationContext` 인터페이스는 빈을 검색하는 몇 가지 다른 방법이 있지만 그것들을 코드상에서 사용하지 않는게 이상적이다. 실제로, 당신의 애플리케이션 코드는 getBean() 메소드에 대한 호출이 전혀 없어야 하며 따라서 스프링 API에 전혀 의존하지 않아야 한다. 예를 들어, 스프링 웹 프레임워크와의 통합은 컨트롤러 및 JSF 관리 빈과 같은 다양한 웹 프레임워크 구성 요소에 대한 의존성 주입을 제공하여 메타데이터(예: 자동 보장 주석)를 통해 특정 빈에 대한 의존성을 선언할 수 있다.

</aside>
